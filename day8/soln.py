# This python solution was generated by translating the Go solution through GPT-3.5
# This is purely used as a benchmark against the Go solution
import argparse, os
from dataclasses import dataclass
from typing import Dict, List
import math


def parse_args() -> str:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "input",
        help="input file (.txt) to be read",
        type=str,
        nargs="?",
        default="input.txt",
    )
    args = parser.parse_args()
    path = os.path.join(os.path.dirname(os.path.realpath(__file__)), args.input)
    if os.path.isfile(path):
        return path
    else:
        raise FileNotFoundError(f"Input file {path} not found!")


@dataclass
class Instruction:
    def __init__(self, value: str):
        self.value = value

    @staticmethod
    def LEFT() -> str:
        return "L"

    @staticmethod
    def RIGHT() -> str:
        return "R"

    def __str__(self) -> str:
        return self.value


@dataclass
class Node:
    def __init__(self, value: str):
        self.value = value

    def __eq__(self, other):
        return self.value == other

    def __hash__(self):
        return hash(self.value)

    def __str__(self) -> str:
        return self.value

    def last_char(self) -> str:
        return self.value[-1]

    def is_start_node(self) -> bool:
        return self.last_char() == "A"

    def is_end_node(self) -> bool:
        return self.last_char() == "Z"


@dataclass
class NodePair:
    def __init__(self, first: Node, second: Node):
        self.first = first
        self.second = second

    def next(self, instruction: Instruction) -> Node:
        return self.first if instruction.value == Instruction.LEFT() else self.second

    def __str__(self) -> str:
        return f"[{self.first.value}, {self.second.value}]"


def parse_instructions(line: str) -> List[Instruction]:
    return [Instruction(ins) for ins in line.strip("\n ")]


def parse_network(lines: List[str]) -> Dict[Node, NodePair]:
    network: Dict[Node, NodePair] = {}
    for line in lines:
        parts = line.split("=")
        node = Node(parts[0].strip())
        values = parts[1].strip("()\n ").split(",")
        network[node] = NodePair(Node(values[0].strip()), Node(values[1].strip()))
    return network


def calculate_steps_required(
    network: Dict[Node, NodePair], instructions: List[Instruction]
) -> int:
    num_instructions = len(instructions)
    current, end, instr_idx, steps = Node("AAA"), Node("ZZZ"), 0, 0
    while current != end:
        if instr_idx == num_instructions:
            instr_idx = 0
        instruction = instructions[instr_idx]
        if current not in network:
            raise ValueError(f"node {current} not in network")
        pair = network[current]
        next_node = pair.next(instruction)
        current = next_node
        instr_idx += 1
        steps += 1
    return steps


def calculate_steps_required_p2(
    network: Dict[Node, NodePair], instructions: List[Instruction]
) -> int:
    num_instructions = len(instructions)
    current_nodes = find_all_starter_nodes(network)
    node_steps = []
    for current in current_nodes:
        instr_idx, steps = 0, 0
        while not current.is_end_node():
            if instr_idx == num_instructions:
                instr_idx = 0
            instruction = instructions[instr_idx]
            if current not in network:
                raise ValueError(f"node {current} not in network")
            pair = network[current]
            next_node = pair.next(instruction)
            # print(f"{steps}. {current} --{instruction}-> {pair} = {next_node}")
            current = next_node
            steps += 1
            instr_idx += 1
        node_steps.append(steps)
    return calculate_node_lcms(node_steps)


def calculate_node_lcms(node_steps: List[int]) -> int:
    lcm = 1
    for step_value in node_steps:
        lcm = lcm * step_value // math.gcd(lcm, step_value)
    return lcm


def find_all_starter_nodes(network: Dict[Node, NodePair]) -> List[Node]:
    return [node for node in network.keys() if node.is_start_node()]


def run_p1(lines: List[str]) -> int:
    instructions = parse_instructions(lines[0])
    network = parse_network(lines[2:])
    return calculate_steps_required(network, instructions)


def run_p2(lines: List[str]) -> int:
    instructions = parse_instructions(lines[0])
    network = parse_network(lines[2:])
    return calculate_steps_required_p2(network, instructions)


if __name__ == "__main__":
    input = parse_args()
    with open(input) as file:
        lines = file.readlines()
        print(f"part 1: {run_p1(lines)}")
        print(f"part 2: {run_p2(lines)}")
