# This python solution was generated by translating the Go solution through GPT-3.5
# This is purely used as a benchmark against the Go solution
import argparse, os
import math
from typing import List


def parse_args() -> str:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "input",
        help="input file (.txt) to be read",
        type=str,
        nargs="?",
        default="input.txt",
    )
    args = parser.parse_args()
    input_dir = os.path.dirname(os.path.realpath(__file__))
    path = os.path.join(input_dir, args.input)
    if os.path.isfile(path):
        return path
    else:
        raise FileNotFoundError(f"Input file {path} not found!")


def get_times_and_distances(lines: List[str]) -> tuple[list[str], list[str]]:
    times = list(lines[0].split()[1:])
    distances = list(lines[1].split()[1:])
    return times, distances


def make_float(val: str) -> float:
    try:
        return float(val)
    except ValueError:
        raise ValueError(f"{val} is not a valid float!")


def get_possible_ways(total_time: float, target_distance: float) -> int:
    # Solve the quadratic equation
    roots = [
        (-total_time + sign * math.sqrt(total_time**2 - (4 * target_distance) - 1))
        / -2.0
        for sign in (1, -1)
    ]

    high_val, low_val = max(roots), min(roots)

    return int(math.ceil(high_val) - math.floor(low_val) - 1)


def run_p1(lines: List[str]) -> int:
    times, distances = get_times_and_distances(lines)
    result = 1
    for time_str, distance_str in zip(times, distances):
        time, distance = make_float(time_str), make_float(distance_str)
        ways = get_possible_ways(time, distance)
        result *= ways
    return result


def run_p2(lines: List[str]) -> int:
    times, distances = get_times_and_distances(lines)
    time = make_float("".join(times))
    distance = make_float("".join(distances))
    return get_possible_ways(time, distance)


if __name__ == "__main__":
    input = parse_args()
    with open(input) as file:
        lines = file.readlines()
        print(f"part 1: {run_p1(lines)}")
        print(f"part 2: {run_p2(lines)}")
