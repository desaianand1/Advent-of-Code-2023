# This python solution was generated by translating the Go solution through GPT-3.5
# This is purely used as a benchmark against the Go solution
import argparse, os
import os
from typing import List, Tuple


def parse_args() -> str:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "input",
        help="input file (.txt) to be read",
        type=str,
        nargs="?",
        default="input.txt",
    )
    args = parser.parse_args()
    input_dir = os.path.dirname(os.path.realpath(__file__))
    path = os.path.join(input_dir, args.input)
    if os.path.isfile(path):
        return path
    else:
        raise FileNotFoundError(f"Input file {path} not found!")


class Range:
    def __init__(self, start: int, end: int):
        self.start = start
        self.end = end


class Mapping:
    def __init__(self, source: int, destination: int, length: int):
        self.source = source
        self.destination = destination
        self.length = length

    def apply(self, source) -> Tuple[int, bool]:
        diff = source - self.source
        if 0 <= diff < self.length:
            return self.destination + diff, True
        return -1, False

    def apply_range(self, source_range) -> Tuple[Range, Range, Range]:
        start, end = self.source, self.source + self.length - 1
        before, mapped, after = None, None, None

        if source_range.start < start:
            before = Range(source_range.start, min(source_range.end, start - 1))

        if start <= source_range.end and source_range.start <= end:
            new_start, _ = self.apply(max(start, source_range.start))
            new_end, _ = self.apply(min(end, source_range.end))
            mapped = Range(new_start, new_end)

        if source_range.end > end:
            after = Range(max(end + 1, source_range.start), source_range.end)

        return before, mapped, after


class Mappings(list):
    def apply(self, source) -> int:
        for mapping in self:
            diff, ok = mapping.apply(source)
            if ok:
                return diff
        return source

    def apply_range(self, source_range) -> List[Range]:
        ranges_to_be_mapped = [source_range]
        result_ranges = []

        for mapping in self:
            next_ranges = []
            for start_range in ranges_to_be_mapped:
                before, mapped, after = mapping.apply_range(start_range)
                if before:
                    next_ranges.append(before)
                if mapped:
                    result_ranges.append(mapped)
                if after:
                    next_ranges.append(after)
            ranges_to_be_mapped = next_ranges

        result_ranges.extend(ranges_to_be_mapped)
        return result_ranges


class Almanac(list):
    def locations(self, source_range) -> List[Range]:
        ranges = [source_range]

        for mappings in self:
            new_ranges = [
                s for start_range in ranges for s in mappings.apply_range(start_range)
            ]
            ranges = new_ranges

        return ranges


def parse_seeds(line):
    return [int(seed) for seed in line.split()[1:]]


def parse_mapping(line):
    parts = line.split()
    destination, source, length = map(int, parts[:3])
    return Mapping(source, destination, length)


def parse_all_mappings(lines):
    almanac = Almanac()
    for line in lines:
        mappings = Mappings(parse_mapping(section) for section in line.split("\n")[1:])
        almanac.append(mappings)
    return almanac


def run_p1(lines):
    seeds = parse_seeds(lines[0])
    almanac = parse_all_mappings(lines[1:])
    lowest = float("inf")
    for seed in seeds:
        val = seed
        for mappings in almanac:
            val = mappings.apply(val)
        lowest = min(val, lowest)
    return lowest


def run_p2(lines):
    seeds = parse_seeds(lines[0])
    almanac = parse_all_mappings(lines[1:])
    lowest = float("inf")
    for i in range(0, len(seeds), 2):
        locs = almanac.locations(Range(seeds[i], seeds[i] + seeds[i + 1] - 1))
        for s in locs:
            if s.start < lowest:
                lowest = s.start
    return lowest


if __name__ == "__main__":
    input = parse_args()
    with open(input) as file:
        stringContents = file.read().strip()
        lines = stringContents.split("\n\n")
        print(f"part 1: {run_p1(lines)}")
        print(f"part 2: {run_p2(lines)}")
