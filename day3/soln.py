# This python solution was generated by translating the Go solution through GPT-3.5
# This is purely used as a benchmark against the Go solution
import argparse, os


def parse_args() -> str:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "input",
        help="input file (.txt) to be read",
        type=str,
        nargs="?",
        default="input.txt",
    )
    args = parser.parse_args()
    input_dir = os.path.dirname(os.path.realpath(__file__))
    path = os.path.join(input_dir, args.input)
    if os.path.isfile(path):
        return path
    else:
        raise FileNotFoundError(f"Input file {path} not found!")


def is_digit(char):
    return char.isdigit()


def is_symbol(char):
    return not (is_digit(char) or char == ".")


def find_complete_numbers_keyed(lines):
    idx_num_map = {}

    for i, line in enumerate(lines):
        is_constructing_num = False
        constructed_num = ""
        num_idxs = []
        for j, ch in enumerate(line):
            is_num = is_digit(ch)

            if is_constructing_num:
                if is_num:
                    num_idxs.append(f"{i},{j}")
                    constructed_num += ch
                else:
                    keyed_num = constructed_num + f";key{i},{j}"
                    for idx in num_idxs:
                        idx_num_map[idx] = keyed_num
                    is_constructing_num = False
                    num_idxs = []
                    constructed_num = ""
            else:
                if is_num:
                    num_idxs.append(f"{i},{j}")
                    constructed_num += ch
                    is_constructing_num = True

            if j == len(line) - 1 and is_constructing_num:
                keyed_num = constructed_num + f";key{i},{j}"
                for idx in num_idxs:
                    idx_num_map[idx] = keyed_num
                is_constructing_num = False
                constructed_num = ""

    return idx_num_map


def unlock_complete_number(keyed_num: str) -> int:
    parts = keyed_num.split(";key")
    if len(parts) < 2:
        raise f"something wrong with keyed num!: {parts} | keyedNum: {keyed_num}"
    num = int(parts[0])
    return num


def delete_all_keys_for_keyed_number(num_idx_map, keyed_num):
    keys_to_del = []
    for key, val in num_idx_map.items():
        if keyed_num == val:
            keys_to_del.append(key)
    for key in keys_to_del:
        del num_idx_map[key]


def run_p1(lines: list[str]) -> int:
    num_idx_map = find_complete_numbers_keyed(lines)
    total_sum = 0

    for i, line in enumerate(lines):
        for j, ch in enumerate(line):
            if is_symbol(ch):
                neighbors = [
                    f"{i},{j-1}",
                    f"{i},{j+1}",
                    f"{i-1},{j}",
                    f"{i+1},{j}",
                    f"{i-1},{j-1}",
                    f"{i-1},{j+1}",
                    f"{i+1},{j-1}",
                    f"{i+1},{j+1}",
                ]
                keyed_num_set = set()

                for neighbor in neighbors:
                    keyed_num = num_idx_map.get(neighbor, None)

                    if keyed_num:
                        keyed_num_set.add(keyed_num)
                        delete_all_keys_for_keyed_number(num_idx_map, keyed_num)

                for x in keyed_num_set:
                    actual_num = unlock_complete_number(x)
                    total_sum += actual_num

    return total_sum


def run_p2(lines: list[str]) -> int:
    num_idx_map = find_complete_numbers_keyed(lines)
    total_sum = 0

    for i, line in enumerate(lines):
        for j, ch in enumerate(line):
            if is_symbol(ch):
                neighbors = [
                    f"{i},{j-1}",
                    f"{i},{j+1}",
                    f"{i-1},{j}",
                    f"{i+1},{j}",
                    f"{i-1},{j-1}",
                    f"{i-1},{j+1}",
                    f"{i+1},{j-1}",
                    f"{i+1},{j+1}",
                ]
                gear_pair = []
                count = 0

                for neighbor in neighbors:
                    keyed_num = num_idx_map.get(neighbor, None)

                    if keyed_num:
                        if count >= 2:
                            gear_pair = []
                            break
                        else:
                            gear_pair[count] = keyed_num
                            delete_all_keys_for_keyed_number(num_idx_map, keyed_num)
                            count += 1

                if count == 2 and gear_pair:
                    gp1, gp2 = gear_pair[0], gear_pair[1]
                    p1 = unlock_complete_number(gp1)
                    p2 = unlock_complete_number(gp2)
                    total_sum += p1 * p2

    return total_sum


if __name__ == "__main__":
    lines = parse_args()
    print(f"part 1: {run_p1(lines)}")
    print(f"part 2: {run_p2(lines)}")
